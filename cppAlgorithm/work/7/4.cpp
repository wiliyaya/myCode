#include <bits/stdc++.h>
using namespace std;
// 二分答案+贪心判定，是解决“分段最小化最大值”这类题的经典套路
int n,k,a[114514],l=-114514,r;
int main() {
  cin>>n>>k;
  for(int i=1;i<=n;i++){
    cin>>a[i];
    l=max(l,a[i]);// 每段和至少要能放下最大的数
    r+=a[i];// 最多就是所有数加一起
  }

  while(l<=r){
    int mid=(l+r)>>1; // 猜测最大段和
    int cnt=0,ls=0;// cnt为新开的段数，ls为当前段的和

    for(int i=1;i<=n;i++){
      if(ls+a[i]<=mid){
        ls+=a[i]; // 当前段还能放下a[i]
      }
      else {
        ls=a[i],cnt++;// 新开一段
      }
    }
    if(cnt>=k){
      // 如果分段数大于k，说明mid太小，必须增大左端点。
      l=mid+1;
    }
    else {
      // 如果分段数cnt+1（因为最后一段没计数）小于k，说明mid可以更小，尝试缩小右端点
      r=mid-1;
    }
  }
  cout<<l<<endl; // l是最小的满足条件的值
  return 0;
}
// 1. 为什么能用二分答案？
// 题目要求“每段和的最大值最小”，这是一个最小化最大值的问题。
// 你可以“猜”一个最大值mid，然后问自己：能不能用不超过k段，每段和都≤mid，把所有数分完？
// 如果能做到，说明mid可以更小；如果做不到，说明mid太小了。
// 这种“猜一个答案，然后用判定法验证”的问题，只要满足“答案具有单调性”（即mid越大越容易满足），就可以用二分答案。
// 2. 贪心判定的原理
// 每次尽量往当前段里塞数，只要不超过mid就继续，否则就新开一段。
// 这样分出来的段数一定是最少的（贪心保证）。
// 只要段数不超过k，说明mid可行。